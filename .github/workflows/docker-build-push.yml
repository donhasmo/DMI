name: Build and push Dockerfiles

on:
  workflow_dispatch:
    inputs:
      dockerfile_urls:
        description: |
          Newline-separated GitHub file URLs to Dockerfiles.
          Example:
          https://github.com/OWNER/REPO/blob/main/path/to/Dockerfile
          https://github.com/OWNER/REPO2/blob/main/Dockerfile
        required: true
        type: string
      image_tags:
        description: |
          Newline-separated image names (with tags) in same order as URLs.
          Example:
          myorg/image1:latest
          myorg/image2:staging
        required: true
        type: string
      registry:
        description: "Docker registry (default docker.io or include hostname like ghcr.io)"
        required: false
        default: "docker.io"
      force_pull:
        description: "Set to 'true' to run 'git fetch' for each repo (default false)"
        required: false
        default: "false"

env:
  # workspace directory where repos will be cloned
  WORKDIR: ${{ github.workspace }}/repos

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Prepare workspace
        run: |
          mkdir -p "${WORKDIR}"
          echo "workdir=${WORKDIR}"

      - name: Set up QEMU and Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log into registry
        uses: docker/login-action@v2
        with:
          registry: ${{ github.event.inputs.registry || env.REGISTRY || 'docker.io' }}
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Build and push each Dockerfile
        id: build_push
        run: |
          set -euo pipefail
          # Inputs
          DOCKERFILE_URLS="${{ github.event.inputs.dockerfile_urls }}"
          IMAGE_TAGS="${{ github.event.inputs.image_tags }}"
          REGISTRY="${{ github.event.inputs.registry || 'docker.io' }}"
          FORCE_PULL="${{ github.event.inputs.force_pull || 'false' }}"

          # Normalize newlines -> arrays (strip empty lines)
          mapfile -t URLS < <(printf '%s\n' "$DOCKERFILE_URLS" | awk 'NF')
          mapfile -t TAGS < <(printf '%s\n' "$IMAGE_TAGS" | awk 'NF')

          if [ "${#URLS[@]}" -ne "${#TAGS[@]}" ]; then
            echo "❌ Number of dockerfile URLs (${#URLS[@]}) does not match number of image tags (${#TAGS[@]})."
            exit 1
          fi

          echo "Found ${#URLS[@]} pairs to build."

          idx=0
          for url in "${URLS[@]}"; do
            tag="${TAGS[idx]}"
            echo
            echo "====> Processing #$((idx+1)): ${url} -> ${tag}"
            # Example URL forms to handle:
            # https://github.com/OWNER/REPO/blob/BRANCH/path/to/Dockerfile
            # https://github.com/OWNER/REPO/raw/BRANCH/path/to/Dockerfile
            # https://github.com/OWNER/REPO/path/to/Dockerfile  (rare)
            #
            # Parse owner/repo/branch/path
            url_no_query=$(echo "$url" | sed 's#\?.*$##')
            # remove trailing slash
            url_no_query=${url_no_query%/}

            # extract path segments
            # break into parts after github.com/
            after_github=$(echo "$url_no_query" | sed -E 's#https?://github\.com/##')
            if [ "$after_github" = "$url_no_query" ]; then
              echo "Unsupported URL (not a github.com URL): $url"
              exit 1
            fi

            # if URL contains /blob/ or /raw/, use that to find branch
            if echo "$after_github" | grep -q '/blob/' ; then
              owner_repo=$(echo "$after_github" | cut -d'/' -f1,2)
              branch=$(echo "$after_github" | cut -d'/' -f4)
              path_in_repo=$(echo "$after_github" | cut -d'/' -f5-)
            elif echo "$after_github" | grep -q '/raw/' ; then
              owner_repo=$(echo "$after_github" | cut -d'/' -f1,2)
              branch=$(echo "$after_github" | cut -d'/' -f4)
              path_in_repo=$(echo "$after_github" | cut -d'/' -f5-)
            else
              # fallback: assume form OWNER/REPO/... (no blob), branch default to main
              owner_repo=$(echo "$after_github" | cut -d'/' -f1,2)
              branch="main"
              path_in_repo=$(echo "$after_github" | cut -d'/' -f3-)
            fi

            if [ -z "$owner_repo" ] || [ -z "$path_in_repo" ]; then
              echo "Failed to parse owner/repo/path from URL: $url"
              exit 1
            fi

            owner=$(echo "$owner_repo" | cut -d'/' -f1)
            repo=$(echo "$owner_repo" | cut -d'/' -f2)

            clone_dir="${WORKDIR}/${owner}_${repo}_${idx}"
            echo "Cloning repo ${owner}/${repo} (branch: ${branch}) into ${clone_dir}"
            rm -rf "${clone_dir}"
            git clone --depth 1 --single-branch --branch "${branch}" "https://github.com/${owner}/${repo}.git" "${clone_dir}" || {
              echo "Clone failed (trying default branch 'main')..."
              git clone --depth 1 "https://github.com/${owner}/${repo}.git" "${clone_dir}"
            }

            # Determine Dockerfile location and build context
            dockerfile_rel="${path_in_repo}"
            dockerfile_abs="${clone_dir}/${dockerfile_rel}"
            if [ ! -f "${dockerfile_abs}" ]; then
              echo "Dockerfile not found at ${dockerfile_abs} — aborting."
              exit 1
            fi

            # Build context = dir that contains the Dockerfile
            context_dir=$(dirname "${dockerfile_abs}")
            df_basename=$(basename "${dockerfile_abs}")

            echo "Dockerfile path: ${dockerfile_abs}"
            echo "Build context: ${context_dir}"
            echo "Using Dockerfile name: ${df_basename}"

            # If registry is docker.io and tag does not include a registry, keep tag
            # If using ghcr.io or custom registry user should include it in tag
            echo "Building and pushing ${tag} ..."

            # Use buildx action via CLI (buildx is set up by earlier action)
            docker buildx build \
              --platform linux/amd64 \
              --push \
              --tag "${tag}" \
              --file "${dockerfile_abs}" \
              "${context_dir}"

            echo "Finished build for ${tag}"

            idx=$((idx+1))
          done

          echo "All builds completed."
