name: Build & Push Dockerfiles

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: 'Git repo URL (HTTPS). Example: https://github.com/owner/repo.git'
        required: true
      repo_token:
        description: '(optional) Token to access private repo (use a secret). If empty public access used'
        required: false
      registry:
        description: 'Docker registry host (optional). Example: docker.io or ghcr.io'
        required: false
        default: 'docker.io'
      paths:
        description: |
          Newline-separated list of folders that contain Dockerfile(s) relative to repo root.
          Example:
          book-review-app/backend
          book-review-app/frontend
        required: true
      images:
        description: |
          Newline-separated list of image names (each item corresponds to a path line).
          Each entry should include the tag. Examples:
          myuser/backend:staging
          myuser/frontend:staging
          If the image name does not contain a '/', the workflow will prefix it with the registry input.
        required: true

env:
  CLONE_DIR: repo-src

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      artifact-name: repo-src
    steps:
      - name: Install jq (for json handling)
        run: sudo apt-get update && sudo apt-get install -y jq git

      - name: Clone target repo
        id: clone
        run: |
          echo "Cloning ${GITHUB_EVENT_INPUTS_repo_url:-${{ github.event.inputs.repo_url }}}"
          REPO_URL="${{ github.event.inputs.repo_url }}"
          # Use repo_token if provided
          if [ -n "${{ github.event.inputs.repo_token }}" ]; then
            # insert token into URL for private repo access
            # repo_token should be stored as a secret when dispatching (if necessary)
            REPO_URL="${REPO_URL/https:\/\//https:\/\/${{ github.event.inputs.repo_token }}@}"
          fi
          git clone --depth 1 "$REPO_URL" "$CLONE_DIR"
          echo "cloned to $CLONE_DIR"

      - name: Build matrix JSON from inputs
        id: set-matrix
        run: |
          # Build matrix JSON from inputs (robust: accepts newline OR space separated lists)
          set -euo pipefail

          # inputs (in workflow these are available at github.event.inputs.*)
          INPUT_PATHS="${{ github.event.inputs.paths }}" || true
          INPUT_IMAGES="${{ github.event.inputs.images }}" || true
          REGISTRY="${{ github.event.inputs.registry }}" || true
          CLONE_DIR="${CLONE_DIR:-repo-src}"

          # If REGISTRY empty, default to docker.io
          REGISTRY="${REGISTRY:-docker.io}"

          # Helper: normalize separators -> convert sequences of whitespace to a single newline
          # This allows callers to provide either newline-separated or space-separated lists
          normalize_list() {
          local raw="$1"
          # replace CRLF with LF
          raw="${raw//$'\r'/}"
          # if raw contains any newline, keep those separators; otherwise split on spaces
          if printf '%s' "$raw" | grep -q $'\n'; then
            # collapse multiple blank lines to single newline, trim leading/trailing newlines
            printf '%s' "$raw" | sed '/^[[:space:]]*$/d'
          else
            # split on whitespace into newlines
            printf '%s' "$raw" | tr -s '[:space:]' '\n' | sed '/^[[:space:]]*$/d'
          fi
          }

          # Normalize inputs to arrays (one item per line)
          PATH_LINES_RAW="$(normalize_list "$INPUT_PATHS")"
          IMAGE_LINES_RAW="$(normalize_list "$INPUT_IMAGES")"

          # Build arrays
          IFS=$'\n' read -r -d '' -a PATH_LINES <<< "$(printf '%s\n' "$PATH_LINES_RAW")" || true
          IFS=$'\n' read -r -d '' -a IMAGE_LINES <<< "$(printf '%s\n' "$IMAGE_LINES_RAW")" || true

          # Trim function
          trim() { sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' <<< "$1"; }

          # Clean up paths (remove trailing slashes) and images (trim)
          clean_paths=()
          for p in "${PATH_LINES[@]}"; do
          p="$(trim "$p")"
          # if empty skip
          [ -z "$p" ] && continue
          # remove trailing slash(s)
          p="${p%/}"
          clean_paths+=("$p")
          done

          clean_images=()
          for img in "${IMAGE_LINES[@]}"; do
          img="$(trim "$img")"
          [ -z "$img" ] && continue
          clean_images+=("$img")
          done

          # Verify counts
          if [ "${#clean_paths[@]}" -ne "${#clean_images[@]}" ]; then
          echo "Error: number of paths (${#clean_paths[@]}) and images (${#clean_images[@]}) must match"
          echo "Paths (${#clean_paths[@]}):"
          printf ' - %s\n' "${clean_paths[@]}"
          echo "Images (${#clean_images[@]}):"
          printf ' - %s\n' "${clean_images[@]}"
          exit 1
          fi

          # Build matrix items
          matrix_items=()
          for i in "${!clean_paths[@]}"; do
          p="${clean_paths[$i]}"
          img="${clean_images[$i]}"

          # ensure folder exists in cloned repo
          if [ ! -d "$CLONE_DIR/$p" ]; then
            echo "Error: path '$p' does not exist in cloned repo ($CLONE_DIR)"
            echo "Listing $CLONE_DIR:"
            ls -la "$CLONE_DIR" | sed -n '1,200p'
            exit 1
          fi

          # if image doesn't include a slash (likely no registry/user), prefix with registry (registry/user/image)
          if [[ "$img" != */* ]]; then
            reg="${REGISTRY%/}"
            img="${reg}/${img}"
          fi

          # produce JSON object
          item=$(jq -n --arg path "$p" --arg image "$img" '{path:$path, image:$image}')
          matrix_items+=("$item")
          done

          # join into array JSON
          # matrix_items contains JSON objects as strings; assemble into array with jq
          matrix_json="$(printf '%s\n' "${matrix_items[@]}" | jq -s '.')" || true

          # Output matrix for GitHub Actions
          echo "matrix=$matrix_json" >> "$GITHUB_OUTPUT"
          echo "matrix prepared: $matrix_json"


      - name: Upload repo as artifact
        uses: actions/upload-artifact@v4
        with:
          name: repo-src
          path: ${{ env.CLONE_DIR }}

  build-and-push:
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        # parse matrix JSON produced by prepare job
        include: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - name: Download repo artifact
        uses: actions/download-artifact@v4
        with:
          name: repo-src
          path: repo-src

      - name: Set up QEMU (for multi-arch, optional)
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker registry
        uses: docker/login-action@v2
        with:
          registry: ${{ github.event.inputs.registry }}
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Build and push image (for ${{ matrix.path }})
        uses: docker/build-push-action@v5
        with:
          context: repo-src/${{ matrix.path }}
          # this will find Dockerfile in the folder; customize `file` if your Dockerfile name differs
          push: true
          tags: ${{ matrix.image }}
          # optionally set platforms: linux/amd64,linux/arm64
          # platforms: linux/amd64
          # cache-from/cache-to can be configured if you have a registry cache

      - name: Show pushed image
        run: echo "Pushed ${{ matrix.image }}"
