name: Build & Push Dockerfiles

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: 'Git repo URL (HTTPS). Example: https://github.com/owner/repo.git'
        required: true
      repo_token:
        description: '(optional) Token to access private repo (use a secret). If empty public access used'
        required: false
      registry:
        description: 'Docker registry host (optional). Example: docker.io or ghcr.io'
        required: false
        default: 'docker.io'
      paths:
        description: |
          Newline-separated list of folders that contain Dockerfile(s) relative to repo root.
          Example:
          book-review-app/backend
          book-review-app/frontend
        required: true
      images:
        description: |
          Newline-separated list of image names (each item corresponds to a path line).
          Each entry should include the tag. Examples:
          myuser/backend:staging
          myuser/frontend:staging
          If the image name does not contain a '/', the workflow will prefix it with the registry input.
        required: true

env:
  CLONE_DIR: repo-src

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      artifact-name: repo-src
    steps:
      - name: Install jq (for json handling)
        run: sudo apt-get update && sudo apt-get install -y jq git

      - name: Clone target repo
        id: clone
        run: |
          echo "Cloning ${GITHUB_EVENT_INPUTS_repo_url:-${{ github.event.inputs.repo_url }}}"
          REPO_URL="${{ github.event.inputs.repo_url }}"
          # Use repo_token if provided
          if [ -n "${{ github.event.inputs.repo_token }}" ]; then
            # insert token into URL for private repo access
            # repo_token should be stored as a secret when dispatching (if necessary)
            REPO_URL="${REPO_URL/https:\/\//https:\/\/${{ github.event.inputs.repo_token }}@}"
          fi
          git clone --depth 1 "$REPO_URL" "$CLONE_DIR"
          echo "cloned to $CLONE_DIR"

      - name: Build matrix JSON from inputs
        id: set-matrix
        run: |
          # Build matrix JSON from inputs (robust: accepts newline OR space separated lists)
          # Build matrix JSON from inputs (robust: accepts newline OR space separated lists)
          set -euo pipefail

          # inputs (replace these with github.event.inputs.* in the workflow)
          INPUT_PATHS="${{ github.event.inputs.paths }}"    # e.g. "backend/ frontend/" or "backend\ndefault/"
          INPUT_IMAGES="${{ github.event.inputs.images }}"  # e.g. "hasmo/backend:test hasmo/frontend:test"
          REGISTRY="${{ github.event.inputs.registry }}"    # e.g. docker.io
          CLONE_DIR="${CLONE_DIR:-repo-src}"

          # default registry
          REGISTRY="${REGISTRY:-docker.io}"

          # Helper: normalize separators -> convert whitespace (spaces/tabs/newlines) into single newline list
          normalize_list() {
            local raw="$1"
            # strip CRs
            raw="${raw//$'\r'/}"
            # if contains newline, keep lines; otherwise split on whitespace
            if printf '%s' "$raw" | grep -q $'\n'; then
              # remove empty lines, trim leading/trailing whitespace per line
              printf '%s\n' "$raw" | sed '/^[[:space:]]*$/d'
            else
              # split on whitespace into lines
              printf '%s\n' "$raw" | tr -s '[:space:]' '\n' | sed '/^[[:space:]]*$/d'
            fi
          }

          # Normalize inputs
          PATH_LINES_RAW="$(normalize_list "$INPUT_PATHS")"
          IMAGE_LINES_RAW="$(normalize_list "$INPUT_IMAGES")"

          # Read into arrays using mapfile for robust splitting
          mapfile -t PATH_LINES <<< "$PATH_LINES_RAW" || true
          mapfile -t IMAGE_LINES <<< "$IMAGE_LINES_RAW" || true

          # Trim helper (bash)
          trim() { sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' <<< "$1"; }

          # Clean and normalize paths/images
          clean_paths=()
          for p in "${PATH_LINES[@]}"; do
            p="$(trim "$p")"
            [ -z "$p" ] && continue
            # remove trailing slash(es)
            p="${p%/}"
            clean_paths+=("$p")
          done

          clean_images=()
          for img in "${IMAGE_LINES[@]}"; do
            img="$(trim "$img")"
            [ -z "$img" ] && continue
            clean_images+=("$img")
          done

          # Verify counts match
          if [ "${#clean_paths[@]}" -ne "${#clean_images[@]}" ]; then
            echo "Error: number of paths (${#clean_paths[@]}) and images (${#clean_images[@]}) must match"
            echo "Paths (${#clean_paths[@]}):"
            printf ' - %s\n' "${clean_paths[@]}"
            echo "Images (${#clean_images[@]}):"
            printf ' - %s\n' "${clean_images[@]}"
            exit 1
          fi

          # Build matrix JSON
          matrix_items=()
          for i in "${!clean_paths[@]}"; do
            p="${clean_paths[$i]}"
            img="${clean_images[$i]}"

            # ensure path exists in cloned repo
            if [ ! -d "$CLONE_DIR/$p" ]; then
              echo "Error: path '$p' does not exist in cloned repo ($CLONE_DIR)"
              echo "Listing $CLONE_DIR:"
              ls -la "$CLONE_DIR" | sed -n '1,200p'
              exit 1
            fi

            # if image doesn't contain a '/', prefix registry (e.g. docker.io)
            if [[ "$img" != */* ]]; then
              reg="${REGISTRY%/}"
              img="${reg}/${img}"
            fi

            item=$(jq -n --arg path "$p" --arg image "$img" '{path:$path, image:$image}')
            matrix_items+=("$item")
          done

          # assemble JSON array
          matrix_json="$(printf '%s\n' "${matrix_items[@]}" | jq -s '.')" || true

          # export for GitHub Actions
          echo "matrix=$matrix_json" >> "$GITHUB_OUTPUT"
          echo "matrix prepared: $matrix_json"



      - name: Upload repo as artifact
        uses: actions/upload-artifact@v4
        with:
          name: repo-src
          path: ${{ env.CLONE_DIR }}

  build-and-push:
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        # parse matrix JSON produced by prepare job
        include: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - name: Download repo artifact
        uses: actions/download-artifact@v4
        with:
          name: repo-src
          path: repo-src

      - name: Set up QEMU (for multi-arch, optional)
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker registry
        uses: docker/login-action@v2
        with:
          registry: ${{ github.event.inputs.registry }}
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Build and push image (for ${{ matrix.path }})
        uses: docker/build-push-action@v5
        with:
          context: repo-src/${{ matrix.path }}
          # this will find Dockerfile in the folder; customize `file` if your Dockerfile name differs
          push: true
          tags: ${{ matrix.image }}
          # optionally set platforms: linux/amd64,linux/arm64
          # platforms: linux/amd64
          # cache-from/cache-to can be configured if you have a registry cache

      - name: Show pushed image
        run: echo "Pushed ${{ matrix.image }}"
